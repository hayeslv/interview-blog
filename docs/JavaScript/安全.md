# JavaScript代码安全规范



## 一、代码实现

### 1.1原生DOM API的安全操作

#### 1.1.1 【必须】HTML标签操作，限定/过滤传入变量值

- 使用 `innerHTML=`、`outerHTML=`、`document.write()`、`document.writeln()`时，如变量值外部可控，应对特殊字符（`& < > " '`）做编码转义，或使用安全的 DOM API 替代

```js
// 假设 params 为用户输入，text 为 DOM 节点
// bad: 将不可信内容带入 HTML 标签操作
const { user } = params;
// ...
text.innerHTML = `Follow @${user}`;

// good: innerHTML 操作前，对特殊字符编码转义
function htmlEncode(iStr) {
  let sStr = iStr;
  sStr = sStr.replace(/&/g, `&`);
  sStr = sStr.replace(/>/g, `>`);
  sStr = sStr.replace(/</g, `<`);
  sStr = sStr.replace(/"/g, `"`);
  sStr = sStr.replace(/'/g, `'`);
  return sStr;
}

const { user } = params;
user = htmlEncode(user);
// ...
text.innerHTML = `Follow @${user}`;

// good: 使用安全的DOM API 替代 innerHTML
const { user } = params;
// ...
text.innerText = `Follow @${user}`;
```



#### 1.1.2 【必须】 HTML属性操作，限定/过滤传入变量值

- 使用 `element.setAttribute(name, value);` 时，如果第一个参数值 `name` 外部可控，应用白名单限定允许操作的属性范围。
- 使用 `element.setAttribute(name, value);` 时，操作 `a.href`、`iframe.src`、`form.action`、`embed.src`、`object.data`、`link.href` 属性时，如第二个参数值 `value` 外部可控，应参考 JavaScript 页面类规范 1.3.1 部分，限定页面重定向或引入资源的目标地址。

```js
// good: setAttribute 操作前，限定引入资源的目标地址
function addExternalCss(e) {
  const t = document.createElement('link');
  t.setAttribute('href', e);
  t.setAttribute('rel', 'stylesheet');
  t.setAttribute('type', 'text/css');
  document.head.appendChild(t);
}

function validURL(sUrl) {
  return !!(
  	(/^(https?:\/\/)?[\w\-.]+\.(qq|tencent)\.com($|\/|\\)/i).test(sUrl)
  	|| (/^[\w][\w/.\-_%]+$/i).test(sUrl)
  	|| (/^[/\\][^/\\]/i).test(sUrl)
  )
}

let sUrl = "https://evil.com/1.css";
if(validURL(sUrl)) {
  addExternalCss(sUrl);
}
```



### 1.2 流行框架/库的安全操作

#### 1.2.1 【必须】 限定/过滤传入 jQuery 不安全含税的变量值

- 使用 `.html()`、`.append()`、`.prepend()`、`.wrap()`、`$()`、`.replaceWith()`、`.wrapAll()`、`.wrapInner()`、`.after()`、`.before()` 时，如变量值外部可控，应对特殊字符（`& < > " '`） 做编码转义。

```js
// bad: 将不可信内容，带入 jQuery 不安全函数 .after() 操作
const { user } = params;
// ...
$("p").after(user);

// good: jQuery 不安全函数 .html() 操作前，对特殊字符编码转义
function htmlEncode(iStr) {
  let sStr = iStr;
  sStr = sStr.replace(/&/g, `&`);
  sStr = sStr.replace(/>/g, `>`);
  sStr = sStr.replace(/</g, `<`);
  sStr = sStr.replace(/"/g, `"`);
  sStr = sStr.replace(/'/g, `'`);
  return sStr;
}

// const user = params.user;
user = htmlEncode(user);
// ...
$("p").html(user);
```

- 使用 `.attr()` 操作 `a.href`、`ifame.src`、`form.action`、`embed.src`、`object.data`、`link.href` 属性时，应参考 JavaScript 页面类规范1.3.1 部分，限定重定向的资源目标地址。
- 使用 `.attr(attributeName, value)` 时，如第一个参数值 `attributeName` 外部可控，应用白名单限定允许操作的属性范围。
- 使用 `$.getScript(url [, success])` 时，如第一个参数值 `url` 外部可控（如：从 URL 取值拼接，请求 jsonp 接口），应限定可控变量值的字符集范围为： `[a-zA-Z0-9_-]+`



#### 1.2.2 【必须】 限定/过滤传入 Vue.js 不安全函数的变量值

- 使用 `v-html` 时，不允许对用户提供的内容使用 HTML 插值。如业务需要，应先对不可信内容做富文本过滤。参考：[vue-xssFilter](https://github.com/hayeslv/vue-xssFilter)

```html
<!-- bad: 直接渲染外部传入的不可信内容 -->
<div v-html="userProvideHtml"></div>

<!-- good: 使用富文本过滤库处理不可信内容后渲染 -->
<!-- 使用 -->
<div v-xss-html="{'mode': 'whitelist', dirty: html, options: options}"></div>
<!-- 配置 -->
<script>
  new Vue({
    el: "#app",
    data: {
      options: {
        whiteList: {
          a: ["href", "titile", "target", "class", "id"],
          div: ["class", "id"],
          span: ["class", "id"],
          img: ["src", "alt"],
        }
      }
    }
  })
</script>
```

- 使用 `v-bind` 操作 `a.href`、`ifame.src`、`form.action`、`embed.src`、`object.data`、`link.href` 时，应确保后端已参考 JavaScript 页面类规范 1.3.1 部分，限定了供前端调用的重定向目标地址。
- 使用 `v-bind` 操作 `style` 属性时，应只允许外部控制特定、可控的 CSS 属性值

```html
<!-- baad: v-bind允许外部可控值，自定义CSS属性值及属性 -->
<a v-bind:href="sanitizedUrl" v-bind:style="userProvidedStyles">
click me
</a>

<!-- good: v-bind只允许外部提供特性、可控的CSS属性值 -->
<a v-bind:href="sanitizedUrl" v-bind:style="{
  color: userProvidedColor,
  background: userProvidedBackground
}">
click me
</a>
```



### 1.3 页面重定向

#### 1.3.1 【必须】 限定跳转目标地址

- 使用白名单，限定重定向地址的协议前缀（默认只允许 HTTP、HTTPS）、域名（默认只允许公司根域），或指定为固定值；
- 适用场景包括，使用函数方法：`location.href`、`window.open()`、`location.assign()`、`location.replace()`；赋值或更新HTML属性：`iframe.src`、`form.action`、`a.href`、`embed.src`、`object.data`;

```js
// bad: 跳转至外部可控的不可信地址
const sTargetUrl = getURLParam("target");
location.replace(sTargetUrl);

// good: 白名单限定重定向地址
function validURL(sUrl) {
  return !!(
  	(/^(https?:\/\/)?[\w\-.]+\.(qq|tencent)\.com($|\/|\\)/i).test(sUrl)
    || (/^[\w][\w/.\-_%]+$/i).test(sUrl)
    || (/^[/\\][^/\\]/i).test(sUrl)
  )
}

const sTargetUrl = getURLParam("target");
if(validURL(sTargetUrl)) {
  location.replace(sTargetUrl);
}

// good: 制定重定向地址为固定值
const sTargetUrl = "http://www.qq.com";
location.replace(sTargetUrl);
```



### 1.4 JSON解析/动态执行

#### 1.4.1 【必须】 使用安全的 JSON 解析方式

- 应使用 `JSON.parse()` 解析JSON字符串。低版本浏览器，应使用安全的 [Polyfill 封装](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)

```js
// bad: 直接调用 eval 解析 json
const sUserInput = getURLParam("json_val");
const jsonstr1 = `{"name": "a", "company": "b", "value": "${sUserInput}"}`;

// good: 使用 JSON.parse 解析
const sUserInput = getURLParam("json_val");
JSON.parse(sUserInput, (k, v) => {
  if(k === "") return v;
  return v * 2;
});

// good: 低版本浏览器，使用安全的 Polyfill 封装（基于eval）
<script src="https://github.com/douglascrockford/JSON-js/blob/master/json2.js"></script>
const sUserInput = getURLParam("json_val");
JSON.parse(sUserInput);
```



### 1.5 跨域通讯

#### 1.5.1 【必须】 使用安全的前端跨域通讯方式

- 具有隔离登录态（如：p_skey）、涉及用户高敏感信息的业务（如微信网页版、QQ空间、QQ邮箱、公众平台），禁止通过 `document.domain` 降域，实现前端跨域通讯，应使用 `postMessage` 替代。



#### 1.5.2 【必须】使用 postMessage 应限定 Origin

- 在 message 事件监听回调中，应先使用 `event.origin` 校验来源，再执行具体操作。
- 校验来源时，应使用 `===` 判断，禁止使用 `indexOf()`

```js
// bad: 使用 indexOf 校验 Origin 值
window.addEventListener("message", e => {
  if(e.origin.indexOf("https://a.qq.com")) {
    // ...
  } else {
    // ... 
  }
})

// good: 使用 postMessage 时，限定 Origin，且使用 === 判断
window.addEventListener("message", e => {
  if(e.origin === "https://a.qq.com") {
    // ...
  }
})
```



## 二、配置&环境

### 2.1 敏感/配置信息

#### 2.1.1【必须】 禁止明文硬编码 AK/SK

- 禁止前端页面的 JS 明文硬编码 AK/SK 类密钥，应封装成后台接口，AK/SK 保存在后端配置中心或密钥管理系统。



### 2.2 第三方组件/资源

#### 2.2.1 【必须】 使用可信范围内的统计组件

- 站点统计分析，应优先使用公司内部组件

Google 统计：`https://analytics.google.com/`



#### 2.2.2【必须】 禁止引入非可信来源的第三方 JS

- 应检查页面内引入第三方 JS 资源是否可控。判断标准如下：
  - 属于公司资产的域名
  - 可信外部公司、合作伙伴的站点



# Node.js 后台类

## 一、代码实现

### 1.1 输入验证

#### 1.1.1 【必须】 按类型进行数据校验

- 所有程序外部输入的参数值，应进行数据校验。校验内容包括但不限于：数据长度、数据范围、数据类型与格式。校验不通过，应拒绝。

```js
// bad: 未进行输入验证
Router.get("/valxss", (req. res) => {
  const { txt } = req.query;
  res.set("Content-Type", "text/html");
  res.send({
    data: txt,
  })
})

// good: 按数据类型，进行输入验证
const Router = require("express").Router();
const validator = require("validator");

Router.get("/email_with_validator", (req, res) => {
  const txt = req.query.txt || "";
  if(validator.isEmail(txt)) {
    res.send({
      data: txt,
    });
  } else {
    res.send({ err: 1 });
  }
})
```



### 1.2 执行命令

#### 1.2.1 【必须】 使用 child_process 执行系统命令，应限定或校验命令和参数的内容

- 适用场景包括：`child_process.exec`、`child_process.execSync`、`child_process.spawn`、`child_process.spawnSync`、`child_process.execFile`、`child_process.execFileSync`
- 调用上述函数，应首先考虑限定范围，供用户选择。
- 使用 `child_process.exec` 或 `child_process.execSync` 时，如果可枚举输入的参数内容或者格式，则应限定白名单。如果无法枚举命令或参数，则必须过滤或者转义指定符号，包括： | ; & $ ( ) > <  `  !
- 使用 `child_process.spawn` 或 `child_process.execFile` 时，应校验传入的命令和参数在可控列表内。

```js
const Router = require("express").Router();
const validator = require("validator");
const { exec } = require("child_process");

// bad: 未限定或过滤，直接执行命令
Router.get("val_cmd_inject", (req, res) => {
  const tex = req.query.txt || "echo 1";
  exec(txt, (err, stdout, stderr) => {
    if(err) { res.send({ err: 1 }) }
    res.send({ stdout, stderr });
  })
})

// good: 通过白名单，限定外部可执行命令范围
Router.get("/not_val_cmd_inject", (req, res) => {
  const txt = req.query.txt || "echo 1";
  const phone = req.query.phone || "";
  const cmdList = {
    sendmsg: "./sendmsg"
  };
  if(txt in cmdList && validator.isMobilePhone(phone)) {
    exec(cmdList[txt] + phone, (err, stdout, stderr) => {
      if(err) { res.send({ err: 1 }) };
      res.send({ stdout, stderr });
    })
  } else {
    res.send({
      err: 1,
      tips: `you can use '${Object.keys(cmdList)}'`
    })
  }
})

// good: 执行命令前，过滤/转义指定符号
Router.get("/not_val_cmd_inject", (req, res) => {
  const txt = req.query.txt || "echo 1";
  let phone = req.query.phone || "";
  const cmdList = {
    sendmsg: "./sendmsg"
  }
  phone = phone.replace(/\||;|&|\$\(|\)|>|<|`|!/gi, "");
  if(txt in cmdList) {
    exec(cmdList[txt] + phone, (err, stdout, stderr) => {
      if(err) { res.send({ err: 1 }) };
      res.send({ stdout, stderr });
    })
  } else {
    res.send({
      err: 1,
      tips: `you can use '${Object.keys(cmdList)}'`
    })
  }
})
```



### 1.3 文件操作

#### 1.3.1 【必须】 限定文件操作的后缀范围

- 按业务需求，使用白名单限定后缀范围。



#### 1.3.2 【必须】校验并限定文件路径范围

- 应固定上传、访问文件的路径。若需要拼接外部可控变量值，检查是否包含 `..` 和 `.` 路径穿越字符。如存在，应拒绝。

```js
const fs = require("fs");
const path = require("path");
let { filename } = req.query;

// bad: 未检查文件名/路径
fs.readFile(filename, (err, data) => {
  if(err) {
    return console.error(err);
  }
  console.log(`异步读取：${data.toString()}`);
})

// good: 检查了文件名/路径，是否包含路径穿越字符
filename = path.normalize(filename);
if(filename.indexOf("..") < 0) {
  fs.readFile(filename, (err, data) => {
    if(err) {
      return console.error(err);
    }
    console.log(data.toString());
  })
}
```



#### 1.3.3 【必须】安全地处理上传文件名

- 将上传文件重命名为 16 位以上的随机字符串保存。
- 如需原样保留文件名，应检查是否包含 `..` 或 `.` 路径穿越字符。如存在，应拒绝。



#### 1.3.4 【必须】敏感资文件，应有加密、鉴权和水印等加固措施

- 用户上传的 **身份证、银行卡** 等图片，属敏感资源文件，应采取安全加固。
- 指向此类文件的 URL，应保证不可预测性；同时，确保无接口会批量展示此类资源的 URL。
- 访问敏感资源文件时，应进行权限控制。默认情况下，仅用户可查看、操作自身敏感资源文件。
- 图片类文件应添加业务水印，表明该图片仅可用于当前业务使用。



### 1.4 网络请求

#### 1.4.1 【必须】 限定访问忘了资源地址范围

- 应固定程序访问网络资源地址的 **协议、域名、路径** 范围。

- 若业务需要，外部可指定访问网络资源地址，应禁止访问内网私有地址段及域名。范围如下：

  ```
  10.0.0.0/8
  172.16.0.0/12
  192.168.0.0/16
  100.64.0.0/10
  9.0.0.0/8
  127.0.0.0/8
  11.0.0.0/8
  30.0.0.0/8
  ```

  



#### 1.4.2 【推荐】请求网络资源，应加密传输

- 应优先选用 https 协议请求网络资源



### 1.5 数据输出

#### 1.5.1 【必须】 高敏感信息禁止存储、展示

- 口令、密保答案、生理标识等鉴权信息禁止展示
- 非金融类业务，信用卡cvv码及日志禁止存储



#### 1.5.2 【必须】 一般敏感信息脱敏展示

- 身份证只显示第一位和最后一位字符，如： `3****************1`
- 移动电话号码隐藏中间6位字符，如：`134******48`
- 工作地址/家庭地址最多显示到 `区` 一级
- 银行卡号仅显示最后4位字符，如： `************8639`



#### 1.5.3 【推荐】 返回的字段按业务需要输出

- 按需输出，避免不必要的用户信息泄露
- 用户敏感数据应在服务器后台处理后输出，不可以先输出到客户端，再通过客户端代码来处理展示



### 1.6 响应输出

#### 1.6.1 【必须】 设置正确的 HTTP 响应包类型

- 响应头 `Content-Type` 与实际响应内容，应保持一致。如：API 响应数据类型是 json，则响应头使用 `application/json`；若为 `xml` ，则设置为 `text/xml`



#### 1.6.2 【必须】添加安全响应头

- 所有接口、页面，添加响应头 `X-Content-Type-Options: nosniff`。
- 所有接口、页面，添加响应头 `X-Frame-Options`。按需合理设置其允许范围，包括：`DENY、SAMEORIGIN、ALLOW-FORM origin`



#### 1.6.3 【必须】外部输入拼接到响应页面前，进行编码处理

| 场景                                                         | 编码规则                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 输出点在HTML标签之间                                         | 需要对以下6个特殊字符进行HTML实体编码（& < > “ ‘）<br />示例：<br />& -> &<br />< -> <<br />> -> ><br />“ -> "<br />‘ -> '<br />/ -> / |
| 输出点在HTML标签普通属性内（如href、src、style等，on事件除外） | 要对数据进行HTML属性编码。<br />编码规则：除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 &#xHH; （以 &#x 开头，HH则是指该字符对应的十六进制数字，分号作为结束符） |
| 输出点在JS内的数据中                                         | 需要进行js编码<br />编码规则：<br />除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII小于256。编码后输出的格式为 \xHH （以 \x 开头，HH则是指该字符对应的十六进制数字）<br />Tips：这种场景仅限于外部数据拼接在 js 里被引号括起来的变量值中。除此之外禁止直接将代码拼接在 js 代码中。 |
| 输出点在CSS中（Style属性）                                   | 需要进行CSS编码<br />编码规则：<br />除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII小于256。编码后输出的格式为 \HH （以 \ 开头，HH则是指该字符对应的十六进制数字） |
| 输出点在URL属性中                                            | 对这些数据进行URL编码<br />Tips：除此之外，所有链接类属性应该校验其协议。禁止 JavaScript、data 和 Vb 伪协议。 |



#### 1.6.4 【必须】 响应禁止展示物理资源、程序内部代码逻辑等敏感信息

- 业务生产（正式）环境，应用异常时，响应内容禁止展示敏感信息。包括但不限于：**物理路径、程序内部源代码、调试日志、内部账号名、内网ip地址** 等。





### 1.7 执行代码

#### 1.7.1 【必须】安全的代码执行方式

- 禁止使用 `eval` 函数
- 禁止使用 `new Function("input")()` 来创建函数
- 使用 `setInterval、setTimeout`，应校验传入的参数





































